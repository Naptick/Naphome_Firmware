<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWS IoT Sensor Monitor</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mqtt@5.3.0/dist/mqtt.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/aws-sdk@2.1491.0/dist/aws-sdk.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/amazon-cognito-identity-js@6.3.9/dist/amazon-cognito-identity.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
        }
        h1 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2em;
        }
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 0.95em;
        }
        .section {
            margin-bottom: 25px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        .section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }
        select, input[type="text"], input[type="password"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 1em;
            transition: border-color 0.3s;
        }
        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s, transform 0.1s;
            margin-right: 10px;
            margin-top: 10px;
        }
        button:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-1px);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .button-danger {
            background: #dc3545;
        }
        .button-danger:hover:not(:disabled) {
            background: #c82333;
        }
        .button-success {
            background: #28a745;
        }
        .button-success:hover:not(:disabled) {
            background: #218838;
        }
        .status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 6px;
            font-size: 0.9em;
        }
        .status-info {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid #17a2b8;
        }
        .status-success {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }
        .status-error {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }
        .status-warning {
            background: #fff3cd;
            color: #856404;
            border-left: 4px solid #ffc107;
        }
        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .sensor-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .sensor-card h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .sensor-value {
            font-size: 2em;
            font-weight: bold;
            color: #333;
            margin: 10px 0;
        }
        .sensor-unit {
            color: #666;
            font-size: 0.9em;
        }
        .sensor-meta {
            font-size: 0.85em;
            color: #999;
            margin-top: 5px;
        }
        .chart-container {
            position: relative;
            height: 300px;
            margin-top: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .hidden {
            display: none;
        }
        .connection-info {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        .connection-info input {
            flex: 1;
            min-width: 200px;
        }
        .device-selector {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        .device-selector select {
            flex: 1;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        .stat-item {
            background: white;
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
        }
        .auth-section {
            margin-top: 15px;
        }
        .auth-section a {
            color: #667eea;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä AWS IoT Sensor Monitor</h1>
        <p class="subtitle">Real-time sensor data monitoring with history graphs</p>

        <div class="section">
            <h2>Connection Settings</h2>
            <div class="form-group hidden">
                <label for="auth-method">Authentication Method:</label>
                <select id="auth-method" onchange="toggleAuthMethod()">
                    <option value="proxy" selected>Backend Proxy (No Credentials Required)</option>
                    <option value="cognito">AWS Cognito Identity Pool</option>
                    <option value="iam">IAM Access Keys</option>
                </select>
            </div>
            <div class="connection-info">
                <div class="form-group" style="flex: 1; min-width: 200px;">
                    <label for="endpoint">AWS IoT Endpoint:</label>
                    <input type="text" id="endpoint" placeholder="xxxxx-ats.iot.region.amazonaws.com" value="a3ag0lenm5av45-ats.iot.ap-south-1.amazonaws.com">
                </div>
                <div class="form-group" style="flex: 1; min-width: 200px;">
                    <label for="region">AWS Region:</label>
                    <input type="text" id="region" placeholder="ap-south-1" value="ap-south-1">
                </div>
            </div>
            <div id="cognito-auth" class="auth-section hidden">
                <div class="connection-info">
                    <div class="form-group" style="flex: 1; min-width: 200px;">
                        <label for="cognito-identity-pool-id">Cognito Identity Pool ID:</label>
                        <input type="text" id="cognito-identity-pool-id" placeholder="ap-south-1:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx">
                    </div>
                </div>
                <div class="status status-info" style="margin-top: 10px;">
                    <strong>Recommended:</strong> Uses temporary credentials via AWS Cognito. No long-lived keys needed. 
                    See <a href="AWS_IOT_TEST_README.md#cognito-setup" target="_blank">setup instructions</a>.
                </div>
            </div>
            <div id="iam-auth" class="auth-section hidden">
                <div class="connection-info">
                    <div class="form-group" style="flex: 1; min-width: 200px;">
                        <label for="access-key">Access Key ID:</label>
                        <input type="text" id="access-key" placeholder="AKIA...">
                    </div>
                    <div class="form-group" style="flex: 1; min-width: 200px;">
                        <label for="secret-key">Secret Access Key:</label>
                        <input type="password" id="secret-key" placeholder="Secret key">
                    </div>
                </div>
                <div class="status status-warning" style="margin-top: 10px;">
                    <strong>Security Note:</strong> IAM keys are long-lived credentials. Consider using Cognito Identity Pools for better security.
                </div>
            </div>
            <div id="proxy-auth" class="auth-section">
                <div class="status status-success" style="margin-top: 10px; margin-bottom: 10px;">
                    <strong>‚úÖ No Credentials Required:</strong> This page uses a secure backend proxy. All authentication is handled server-side. 
                    Just select a device below and click Connect!
                </div>
                <div class="connection-info hidden">
                    <div class="form-group" style="flex: 1; min-width: 200px;">
                        <label for="proxy-url">Proxy Endpoint URL:</label>
                        <input type="text" id="proxy-url" placeholder="https://your-proxy.example.com/connect" value="https://2ushw6qnzf.execute-api.ap-south-1.amazonaws.com/prod/connect">
                    </div>
                </div>
            </div>
            <div class="device-selector">
                <label for="device-select" style="margin: 0; padding-top: 10px;">Device:</label>
                <select id="device-select">
                    <option value="">Select or enter device ID...</option>
                    <option value="SOMNUS_F09E9E3263A4">SOMNUS_F09E9E3263A4</option>
                    <option value="SOMNUS_7A356722B383">SOMNUS_7A356722B383</option>
                </select>
                <input type="text" id="device-custom" placeholder="Or enter custom device ID (SOMNUS_...)" style="flex: 1;">
            </div>
            <button id="connect-btn">üîå Connect</button>
            <button id="disconnect-btn" disabled class="button-danger">Disconnect</button>
            <div id="connection-status"></div>
        </div>

        <div class="section hidden" id="data-section">
            <h2>Live Sensor Data</h2>
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Messages Received</div>
                    <div class="stat-value" id="message-count">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Last Update</div>
                    <div class="stat-value" id="last-update" style="font-size: 1em;">Never</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Connection Status</div>
                    <div class="stat-value" id="conn-status" style="font-size: 1em; color: #28a745;">Connected</div>
                </div>
            </div>
            <div class="sensor-grid" id="sensor-grid"></div>
        </div>

        <div class="section hidden" id="charts-section">
            <h2>History Graphs</h2>
            <div id="charts-container"></div>
        </div>
    </div>

    <script>
        let mqttClient = null;
        // Expose mqttClient to window for testing
        window.mqttClient = null;
        let currentDevice = null;
        let messageCount = 0;
        let sensorData = {};
        let charts = {};
        const MAX_DATA_POINTS = 100; // Keep last 100 data points per sensor

        // Sensor definitions
        const sensors = {
            sht45: {
                name: 'SHT45',
                fields: [
                    { key: 'temperature_c', label: 'Temperature', unit: '¬∞C', color: 'rgb(255, 99, 132)' },
                    { key: 'humidity_rh', label: 'Humidity', unit: '%', color: 'rgb(54, 162, 235)' }
                ]
            },
            scd40: {
                name: 'SCD40',
                fields: [
                    { key: 'co2_ppm', label: 'CO2', unit: 'ppm', color: 'rgb(255, 206, 86)' },
                    { key: 'temperature_c', label: 'Temperature', unit: '¬∞C', color: 'rgb(255, 99, 132)' },
                    { key: 'humidity_rh', label: 'Humidity', unit: '%', color: 'rgb(54, 162, 235)' }
                ]
            },
            sgp40: {
                name: 'SGP40',
                fields: [
                    { key: 'voc_index', label: 'VOC Index', unit: '', color: 'rgb(75, 192, 192)' },
                    { key: 'voc_ticks', label: 'VOC Ticks', unit: '', color: 'rgb(153, 102, 255)' }
                ]
            },
            vcnl4040: {
                name: 'VCNL4040',
                fields: [
                    { key: 'ambient_lux', label: 'Ambient Light', unit: 'lux', color: 'rgb(255, 159, 64)' },
                    { key: 'proximity', label: 'Proximity', unit: '', color: 'rgb(201, 203, 207)' }
                ]
            },
            ec10: {
                name: 'EC10',
                fields: [
                    { key: 'pm1_0_ug_m3', label: 'PM1.0', unit: '¬µg/m¬≥', color: 'rgb(255, 99, 132)' },
                    { key: 'pm2_5_ug_m3', label: 'PM2.5', unit: '¬µg/m¬≥', color: 'rgb(54, 162, 235)' },
                    { key: 'pm10_ug_m3', label: 'PM10', unit: '¬µg/m¬≥', color: 'rgb(255, 206, 86)' }
                ]
            }
        };

        document.getElementById('connect-btn').addEventListener('click', connect);
        document.getElementById('disconnect-btn').addEventListener('click', disconnect);
        document.getElementById('device-select').addEventListener('change', onDeviceSelect);
        document.getElementById('device-custom').addEventListener('input', onDeviceCustom);

        function toggleAuthMethod() {
            const method = document.getElementById('auth-method').value;
            document.getElementById('cognito-auth').classList.toggle('hidden', method !== 'cognito');
            document.getElementById('iam-auth').classList.toggle('hidden', method !== 'iam');
            document.getElementById('proxy-auth').classList.toggle('hidden', method !== 'proxy');
        }

        function onDeviceSelect() {
            const select = document.getElementById('device-select');
            if (select.value) {
                document.getElementById('device-custom').value = '';
                currentDevice = select.value;
            }
        }

        function onDeviceCustom() {
            const custom = document.getElementById('device-custom').value.trim();
            if (custom) {
                document.getElementById('device-select').value = '';
                currentDevice = custom;
            }
        }

        async function connect() {
            const endpoint = document.getElementById('endpoint').value.trim();
            const region = document.getElementById('region').value.trim();
            const authMethod = document.getElementById('auth-method').value;
            const device = currentDevice || document.getElementById('device-select').value || document.getElementById('device-custom').value.trim();

            if (!endpoint || !region || !device) {
                showStatus('Please fill in endpoint, region, and device ID', 'error');
                return;
            }

            if (!device.startsWith('SOMNUS_')) {
                showStatus('Device ID must start with SOMNUS_', 'error');
                return;
            }

            currentDevice = device;
            showStatus('Connecting to AWS IoT...', 'info');

            try {
                const clientId = `web-client-${Date.now()}`;
                const topic = `device/telemetry/${device}`;
                let credentials = null;

                // Get credentials based on auth method
                if (authMethod === 'cognito') {
                    const identityPoolId = document.getElementById('cognito-identity-pool-id').value.trim();
                    if (!identityPoolId) {
                        showStatus('Please enter Cognito Identity Pool ID', 'error');
                        return;
                    }
                    credentials = await getCognitoCredentials(identityPoolId, region);
                } else if (authMethod === 'iam') {
                    const accessKey = document.getElementById('access-key').value.trim();
                    const secretKey = document.getElementById('secret-key').value.trim();
                    if (!accessKey || !secretKey) {
                        showStatus('Please enter IAM Access Key and Secret Key', 'error');
                        return;
                    }
                    credentials = {
                        accessKeyId: accessKey,
                        secretAccessKey: secretKey
                    };
                } else if (authMethod === 'proxy') {
                    // Use default proxy URL if not provided
                    const proxyUrl = document.getElementById('proxy-url').value.trim() || 'https://2ushw6qnzf.execute-api.ap-south-1.amazonaws.com/prod/connect';
                    await connectViaProxy(proxyUrl, endpoint, region, device, topic);
                    return; // Proxy handles connection differently
                }

                // Configure AWS credentials
                AWS.config.update({
                    accessKeyId: credentials.accessKeyId,
                    secretAccessKey: credentials.secretAccessKey,
                    sessionToken: credentials.sessionToken, // For Cognito
                    region: region
                });

                // Create IoT endpoint URL with SigV4 signing
                const iot = new AWS.Iot();
                const iotData = new AWS.IotData({ endpoint: endpoint });
                
                // For WebSocket MQTT, we need to use the MQTT over WebSockets endpoint
                // AWS IoT WebSocket endpoint format: wss://{endpoint}/mqtt
                // We need to sign the request using SigV4
                
                showStatus('Signing WebSocket URL...', 'info');
                
                // Create signed WebSocket URL
                const signer = new AWS.Signers.V4({
                    service: 'iotdevicegateway',
                    region: region
                }, {
                    accessKeyId: accessKey,
                    secretAccessKey: secretKey
                });

                // Build WebSocket URL with query parameters
                const timestamp = new Date().toISOString().replace(/[:\-]|\.\d{3}/g, '');
                const dateStamp = timestamp.substr(0, 8);
                const credentialScope = `${dateStamp}/${region}/iotdevicegateway/aws4_request`;
                
                // Create canonical request for WebSocket
                const canonicalUri = '/mqtt';
                const canonicalQuerystring = `X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=${encodeURIComponent(`${accessKey}/${credentialScope}`)}&X-Amz-Date=${timestamp}&X-Amz-SignedHeaders=host`;
                
                // Sign the request
                const stringToSign = `GET\n${canonicalUri}\n${canonicalQuerystring}\nhost:${endpoint}\n\nhost\n${AWS.util.crypto.sha256('')}`;
                const signingKey = AWS.util.crypto.hmac(`AWS4${secretKey}`, dateStamp, 'buffer');
                const signingKey2 = AWS.util.crypto.hmac(signingKey, region, 'buffer');
                const signingKey3 = AWS.util.crypto.hmac(signingKey2, 'iotdevicegateway', 'buffer');
                const signingKey4 = AWS.util.crypto.hmac(signingKey3, 'aws4_request', 'buffer');
                const signature = AWS.util.crypto.hmac(signingKey4, stringToSign, 'hex');
                
                const signedQuerystring = `${canonicalQuerystring}&X-Amz-Signature=${signature}`;
                const wsUrl = `wss://${endpoint}${canonicalUri}?${signedQuerystring}`;

                // Using MQTT.js with signed WebSocket URL
                const mqtt = window.mqtt;
                const options = {
                    clientId: clientId,
                    protocol: 'wss',
                    reconnectPeriod: 5000,
                    connectTimeout: 10000,
                    transformWsUrl: (url) => wsUrl // Use signed URL
                };

                mqttClient = mqtt.connect(wsUrl, options);
                // Expose to window for testing
                window.mqttClient = mqttClient;
                setupMqttHandlers(topic);

            } catch (error) {
                showStatus(`Connection failed: ${error.message}`, 'error');
            }
        }

        function disconnect() {
            if (mqttClient) {
                mqttClient.end();
                mqttClient = null;
                window.mqttClient = null;
            }
            document.getElementById('connect-btn').disabled = false;
            document.getElementById('disconnect-btn').disabled = true;
            document.getElementById('conn-status').textContent = 'Disconnected';
            document.getElementById('conn-status').style.color = '#dc3545';
            showStatus('Disconnected', 'info');
        }

        function processSensorData(data) {
            // Update sensor cards
            const grid = document.getElementById('sensor-grid');
            grid.innerHTML = '';

            // Process each sensor type
            Object.keys(sensors).forEach(sensorKey => {
                if (data[sensorKey]) {
                    const sensor = sensors[sensorKey];
                    const sensorInfo = data[sensorKey];
                    
                    sensor.fields.forEach(field => {
                        if (sensorInfo[field.key] !== undefined) {
                            const value = sensorInfo[field.key];
                            const isSynthetic = sensorInfo.synthetic || false;
                            
                            // Store data for charts
                            const dataKey = `${sensorKey}_${field.key}`;
                            if (!sensorData[dataKey]) {
                                sensorData[dataKey] = [];
                            }
                            sensorData[dataKey].push({
                                x: new Date(data.timestamp_ms || Date.now()),
                                y: value
                            });
                            
                            // Keep only last MAX_DATA_POINTS
                            if (sensorData[dataKey].length > MAX_DATA_POINTS) {
                                sensorData[dataKey].shift();
                            }
                            
                            // Update chart
                            if (charts[dataKey]) {
                                charts[dataKey].data.datasets[0].data = sensorData[dataKey];
                                charts[dataKey].update('none');
                            }
                            
                            // Create/update sensor card
                            let card = document.getElementById(`card-${dataKey}`);
                            if (!card) {
                                card = document.createElement('div');
                                card.className = 'sensor-card';
                                card.id = `card-${dataKey}`;
                                grid.appendChild(card);
                            }
                            
                            card.innerHTML = `
                                <h3>${sensor.name} - ${field.label}</h3>
                                <div class="sensor-value">${value.toFixed(2)}<span class="sensor-unit"> ${field.unit}</span></div>
                                <div class="sensor-meta">
                                    ${isSynthetic ? '‚ö†Ô∏è Synthetic Data' : '‚úÖ Real Data'} | 
                                    Updated: ${new Date().toLocaleTimeString()}
                                </div>
                            `;
                        }
                    });
                }
            });
        }

        function initializeCharts() {
            const container = document.getElementById('charts-container');
            container.innerHTML = '';

            Object.keys(sensors).forEach(sensorKey => {
                const sensor = sensors[sensorKey];
                sensor.fields.forEach(field => {
                    const dataKey = `${sensorKey}_${field.key}`;
                    const chartId = `chart-${dataKey}`;
                    
                    const chartDiv = document.createElement('div');
                    chartDiv.className = 'chart-container';
                    chartDiv.innerHTML = `<canvas id="${chartId}"></canvas>`;
                    container.appendChild(chartDiv);
                    
                    const ctx = document.getElementById(chartId).getContext('2d');
                    charts[dataKey] = new Chart(ctx, {
                        type: 'line',
                        data: {
                            datasets: [{
                                label: `${sensor.name} - ${field.label}`,
                                data: [],
                                borderColor: field.color,
                                backgroundColor: field.color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                                borderWidth: 2,
                                fill: true,
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    type: 'time',
                                    time: {
                                        displayFormats: {
                                            second: 'HH:mm:ss'
                                        }
                                    },
                                    title: {
                                        display: true,
                                        text: 'Time'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: `${field.label} (${field.unit})`
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: true
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false
                                }
                            }
                        }
                    });
                });
            });
        }

        function showStatus(message, type = 'info') {
            const status = document.getElementById('connection-status');
            status.className = `status status-${type}`;
            status.textContent = message;
        }

        // Get temporary credentials from Cognito Identity Pool
        async function getCognitoCredentials(identityPoolId, region) {
            showStatus('Getting temporary credentials from Cognito...', 'info');
            
            // Initialize Cognito Identity
            AWS.config.region = region;
            const cognitoIdentity = new AWS.CognitoIdentity({ region: region });
            
            // Get ID from identity pool
            const getIdParams = { IdentityPoolId: identityPoolId };
            const identityIdResponse = await cognitoIdentity.getId(getIdParams).promise();
            const identityId = identityIdResponse.IdentityId;
            
            // Get credentials for the identity
            const getCredentialsParams = { IdentityId: identityId };
            const credentialsResponse = await cognitoIdentity.getCredentialsForIdentity(getCredentialsParams).promise();
            
            return {
                accessKeyId: credentialsResponse.Credentials.AccessKeyId,
                secretAccessKey: credentialsResponse.Credentials.SecretKey,
                sessionToken: credentialsResponse.Credentials.SessionToken
            };
        }

        // Connect via backend proxy (uses GitHub Secrets)
        async function connectViaProxy(proxyUrl, endpoint, region, device, topic) {
            showStatus('Connecting via backend proxy...', 'info');
            
            try {
                // Ensure proxy URL doesn't have duplicate /connect
                const apiUrl = proxyUrl.endsWith('/connect') ? proxyUrl : `${proxyUrl}/connect`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        endpoint: endpoint,
                        region: region,
                        device: device,
                        topic: topic
                    })
                });
                
                if (!response.ok) {
                    let errorMessage = `Proxy error: ${response.status} ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        if (errorData.error) {
                            errorMessage += ` - ${errorData.error}`;
                        }
                    } catch (e) {
                        // Ignore JSON parse errors
                    }
                    throw new Error(errorMessage);
                }
                
                const data = await response.json();
                
                if (data.websocketUrl) {
                    // Proxy provides signed WebSocket URL
                    showStatus('Received signed WebSocket URL, connecting...', 'info');
                    const mqtt = window.mqtt;
                    mqttClient = mqtt.connect(data.websocketUrl, {
                        clientId: `web-client-${Date.now()}`,
                        protocol: 'wss',
                        reconnectPeriod: 5000,
                        connectTimeout: 10000
                    });
                    // Expose to window for testing
                    window.mqttClient = mqttClient;
                    setupMqttHandlers(topic);
                } else {
                    throw new Error('Proxy did not return websocketUrl. Response: ' + JSON.stringify(data));
                }
            } catch (error) {
                console.error('Proxy connection error:', error);
                showStatus(`Proxy connection failed: ${error.message}`, 'error');
            }
        }

        function setupMqttHandlers(topic) {
            mqttClient.on('connect', () => {
                console.log('üîå MQTT client connected, subscribing to:', topic);
                showStatus(`Connected! Subscribing to ${topic}...`, 'success');
                mqttClient.subscribe(topic, { qos: 0 }, (err) => {
                    if (err) {
                        console.error('‚ùå Subscription error:', err);
                        showStatus(`Subscription error: ${err.message}`, 'error');
                    } else {
                        console.log('‚úÖ Successfully subscribed to:', topic);
                        showStatus(`Subscribed to ${topic}`, 'success');
                        document.getElementById('connect-btn').disabled = true;
                        document.getElementById('disconnect-btn').disabled = false;
                        document.getElementById('data-section').classList.remove('hidden');
                        document.getElementById('charts-section').classList.remove('hidden');
                        document.getElementById('conn-status').textContent = 'Connected';
                        document.getElementById('conn-status').style.color = '#28a745';
                        initializeCharts();
                        console.log('üìä Waiting for sensor data on topic:', topic);
                    }
                });
            });

            mqttClient.on('message', (topic, message) => {
                try {
                    const data = JSON.parse(message.toString());
                    console.log('üì® MQTT message received:', { topic, dataKeys: Object.keys(data), timestamp: new Date().toISOString() });
                    processSensorData(data);
                    messageCount++;
                    document.getElementById('message-count').textContent = messageCount;
                    document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
                    console.log(`‚úÖ Processed message #${messageCount}, sensor cards: ${document.querySelectorAll('.sensor-card').length}`);
                } catch (error) {
                    console.error('Error parsing message:', error, 'Raw message:', message.toString().substring(0, 200));
                }
            });

            mqttClient.on('error', (error) => {
                showStatus(`Connection error: ${error.message}`, 'error');
                document.getElementById('conn-status').textContent = 'Error';
                document.getElementById('conn-status').style.color = '#dc3545';
            });

            mqttClient.on('close', () => {
                showStatus('Connection closed', 'warning');
                document.getElementById('conn-status').textContent = 'Disconnected';
                document.getElementById('conn-status').style.color = '#dc3545';
            });

            mqttClient.on('offline', () => {
                showStatus('Connection offline', 'warning');
                document.getElementById('conn-status').textContent = 'Offline';
                document.getElementById('conn-status').style.color = '#ffc107';
            });
        }

        // Initialize device selector
        onDeviceSelect();
        
        // Set default auth method to proxy (no credentials required)
        document.getElementById('auth-method').value = 'proxy';
        toggleAuthMethod(); // Initialize auth method display
        
        // Ensure proxy URL has default value even when hidden
        const proxyUrlInput = document.getElementById('proxy-url');
        if (!proxyUrlInput.value.trim()) {
            proxyUrlInput.value = 'https://2ushw6qnzf.execute-api.ap-south-1.amazonaws.com/prod/connect';
        }
    </script>
</body>
</html>
